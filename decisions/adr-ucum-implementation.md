---
status: accepted
date: 2025-07-01
deciders: Chris Mungall, Montana Smith, Mark Miller, Katherine Heal
consulted: Samantha Obermiller, Bea Meluch, Patrick Kalita, Lee Ann McCue, Sujay Patil, Alicia Clum
informed:
---

# UCUM implementation in NMDC

## Context and Problem Statement

NMDC records measurements in two places: the **submission‑schema**, where values appear as a single `{value}{unit}` string, and the **nmdc-schema, for data storage**, where a `QuantityValue` class stores the numeric part in `has_value` and the unit in `has_unit`. Although many slots document a `preferred_unit` (originating from MIxS), most currently accept any unit (e.g., `cm`, `meter`, or even `banana`), which breaks data interoperability.

A large number of MIxS‑derived slots lack a `preferred_unit` annotation or contain ambiguous or non‑UCUM units, such as:

- `abs_air_humidity` lists "gram per gram or cubic centimeter per cubic centimeter"  
- `efficiency_percent` uses "mg/kg (ppm)"  
- `inside_lux` mislabels a power‑density unit as illuminance, and `rel_humidity_out` has ambiguous humidity units  
- `api` relies on a petroleum‑industry convention

These inconsistencies hinder reliable validation and downstream analysis. By adopting UCUM, we will standardize every measurement to a canonical UCUM symbol, record any unavoidable gaps with `units_alignment_excuse`, and enforce the mapping through the `storage_units` annotation.

To address this, NMDC will adopt the **Unified Code for Units of Measure (UCUM)**, a canonical, machine‑readable set of unit symbols that can be automatically validated. This ADR describes:

- how existing NMDC (meta)data was migrated and restructured into a UCUM‑valid format,  
- how annotations are used to require UCUM units, slot requirements, and how new slots added to the NMDC schema must comply,  
- the ETL updates required for NMDC's data ingest (work in progress),  
- how ingested data can be checked and validated,  
- updates to the submission portal ingest and validation.

## Considered Options

- Create various subclasses of `QuantityValue` for slots we want constrained, example `QuantityValueTemp` where `has_unit` is required and constrained to 'C'. Downside to approach was that a separate `QuantityValue` subclass had to be made for each `has_unit` value we wanted to require.
- Create subclass `QuantityValuewithUnit` where `has_unit` is a required slot and constrained to enum `UnitEnum`. Downside to approach was that any of the `UnitEnum` values could be used for any slot (i.e. 'm' could be used for `temp` slot)

- **Numeric‑only slots with LinkML `unit` metaslot** – Convert all `QuantityValue` slots to scalar numeric types (int/float) and use the LinkML `unit` metaslot to store UCUM symbols, which can represent one or multiple allowed units per slot. This simplifies validation but requires a major schema redesign and breaks compatibility with existing data.  
- **Conversion pipeline on ingest** – Accept any unit in the submission schema and perform extensive unit conversion during ETL ingestion. Flexible for submitters but adds significant engineering overhead and runtime conversion complexity.  
- **Hybrid approach (Chris Mungall’s suggestion)** – Keep the existing `QuantityValue` structure, constrain allowed units to the UCUM symbol for the MIxS‑preferred unit(s), and auto‑convert full‑name units to UCUM on ingest. Balances MIxS alignment with practical data handling.  
- **Exploratory `range_expression` association** – Instead of using `storage_units` annotations, associate slots and units via a `range_expression` (as discussed in PR 2599). This would be an experimental LinkML feature applicable to any project, not just the UCUM case.  
- **Chosen solution** – Introduce a `storage_units` annotation that lists allowed UCUM symbols per slot and enforce it via validation tests. This aligns with the hybrid approach while providing a clear, maintainable mechanism for unit standardisation.

## Decision Outcomes

Upon implementation of UCUM, all NMDC slots with `range: QuantityValue` will have a `storage_units` annotation to designate allowed units and required formats for data.

## Validation

The UCUM implementation introduces several layers of validation:

- **Intrinsic schema validation** – LinkML’s built‑in validation checks that each `QuantityValue` slot either has a non‑empty `storage_units` annotation or a `units_alignment_excuse`. This is enforced by the autogenerated schema tests (`tests/test_units_alignment.py`).  
- **External Python tests** – Additional unit‑specific tests are written in Python (e.g., `tests/test_units_conversion.py`) to verify that the ETL conversion logic correctly maps common full‑name units to their UCUM equivalents and that the `storage_units` annotations are correctly applied across the schema.  
- **LinkML validator plugin** – Patrick Kalita provides a custom LinkML validator plugin (`linkml-validator‑units`) that validates instance data against the `storage_units` constraints, ensuring that submitted data only uses allowed UCUM symbols for each slot. This plugin is under ongoing development by @pkalita-lbl, who is also responsible for the submission-schema connection.

These three mechanisms together guarantee that both the schema definition and the actual data conform to the UCUM standard, while allowing explicit `units_alignment_excuse` entries for slots that cannot be represented in UCUM.

## More Information

### Migrating existing NMDC data

**Implementation of annotations and slot requirements**

The UCUM integration introduces a new annotation `storage_units` on slots of type `QuantityValue`. This annotation lists the allowed UCUM unit symbols (pipe‑separated) and is used by the NMDC validation suite.

This section describes the process for migrating existing data. While the process is established, the migration of all historical data is an ongoing effort.

```
# Example slot definition in a LinkML schema
slot_name:
  range: QuantityValue
  description: "Measured concentration of nitrate"
  storage_units: "mmol/L|g/L"
  # The `preferred_unit` field remains for documentation only
```

**Annotation semantics**

- **`storage_units`** – a free‑form string containing one or more UCUM symbols. Tokens may be separated by pipes.
- The `storage_units` annotation is **mandatory** for every `QuantityValue` slot **unless** a `units_alignment_excuse` is provided; otherwise its absence triggers a validation error.
- Existing slots that cannot be expressed in UCUM retain a `units_alignment_excuse` entry explaining the exception.
- The `UnitEnum` used to validate `storage_units` entries is a project‑specific, organic enumeration of UCUM symbols; it may not be suitable for other schemas.

**Enforcement**

1. **Schema generation** – The LinkML compiler propagates `storage_units` into generated Python/Pydantic models as a class attribute.
2. **Runtime validation** – The `units‑ucum‑validate` test (`tests/test_units_alignment.py`) iterates over all slots, verifies that each `QuantityValue` slot either has a non‑empty `storage_units` or a valid `units_alignment_excuse`.
3. **CI integration** – The test suite runs on every PR; failures block merging until the annotation is added.

**Workflow for new slots**

- Define the slot in the appropriate YAML file under `src/schema/`.
- Add a pipe‑delimited list of UCUM symbols to `storage_units`; each element must match the project’s `UnitEnum`, which is an organic, use‑case‑motivated enumeration and may not be suitable for other schemas.
- Run `make test` locally to ensure the validation passes.
- Document the choice in the ADR under this section.

**Owner responsibilities**

- Audit existing `QuantityValue` slots and populate `storage_units` where possible.
- Add `units_alignment_excuse` entries for slots that cannot use UCUM.
- Update the validation test to reflect any new exception categories.
- Review PRs that modify schema files to ensure compliance.

**Assignments**

- @sujaypatil96: Responsible for ETL updates.
- @pkalita‑lbl: Responsible for submission portal ingest & data validation updates.

The migration to UCUM‑compliant units proceeds through a pipeline that is fully scripted and version‑controlled. All artefacts referenced below exist in the repository or in linked GitHub issues/PRs. *Note: Some of the scripts mentioned in this pipeline, particularly those in the `units/scripts` directory, are semi-optional or non-essential for the core migration process.*

**1. Inventory & proposal generation**

- **Extract slot inventory** – `make units-schema-extract` runs `units/scripts/schema_extract_preferred_units.py` and produces `output/schema_preferred_units.tsv`, a table of every `QuantityValue` slot together with any existing `preferred_unit` annotation.
- **Generate UCUM proposals** – `make units-schema-convert` runs `units/scripts/schema_convert_to_ucum.py` on the TSV above, producing `output/schema_ucum_input.tsv`. This file contains a proposed `storage_units` value for each slot **or** flags the slot as a problem that will need a `units_alignment_excuse`.
- **Reference** – Issue **#552** lists the MIxS slots with missing or inconsistent `preferred_unit` values; PR **#2599** shows the diff of the generated proposals.

**2. Human review & gap list curation**

- Check `output/schema_ucum_input.tsv` and update the definitive gap list in `units/docs/units-problems-definitive.md`. This document records:
  - Slots that can receive a `storage_units` annotation.
  - Slots that cannot be expressed in UCUM and therefore receive a `units_alignment_excuse` (e.g., `api`, `soil_text_measure`).
- The curated TSV is committed back to the repo, becoming the single source of truth for the migration.
- *Note: As of November 2025, two related PRs are pending review by migrators: #2690 (Draft: Start improving slots that had units excuses) and #2689 (Approved: Add storage_units annotations for 7 slots reviewed in PR #2653).

**3. Apply annotations to the schema**

- **Generate yq commands** – `make units-schema-generate` runs `units/scripts/schema_generate_yq_commands.py` which reads the curated TSV and writes two command files:
  - `output/yq_commands_single_unit.txt` – one‑liner `yq` commands for slots with a single allowed unit.
  - `output/yq_commands_multi_unit.txt` – commands for slots with a pipe‑separated list of allowed units.
- **Apply changes** – Pipe the command files into the shell (or open a PR) to modify the YAML schema files under `src/schema/`. The resulting PR is the one merged as **PR #2599**.

**4.  Production data migration & validation**

- **Export MongoDB** – `make local/mongo_via_api_as_unvalidated_nmdc_database.yaml` uses `pure-export` to dump the live NMDC database to a single YAML file.
- **Validate against new schema** – `make validate-production` (or `ENV=prod` for the release schema) runs `units/validate_production_units.py`. The script checks **every** `has_unit` value in the dump against the newly‑added `storage_units` constraints and produces `production_validation_report.tsv`.
- **Three‑layer test suite** (described in the “# Validation” section) ensures:
  1. Intrinsic LinkML validation (`tests/test_units_alignment.py`).
  2. External conversion tests (`tests/test_units_conversion.py`).
  3. The custom LinkML validator plugin (`linkml-validator‑units`) contributed by @pkalita‑lbl.
- **Documentation update** – Finally, the ADR’s “Migration of existing NMDC data” section and the `units/docs/units-problems-definitive.md` file could be updated to reflect the completed migration.
